#
# Copyright 2016 Minder Labs.
#

#
# http://graphql.org/learn/schema
# https://facebook.github.io/graphql
#

#
# Custom scalars.
# http://graphql.org/learn/schema/#scalar-types
# http://dev.apollodata.com/tools/graphql-tools/scalars.html
# http://dev.apollodata.com/tools/graphql-tools/resolvers.html
# https://github.com/mugli/learning-graphql/blob/master/7.%20Deep%20Dive%20into%20GraphQL%20Type%20System.md
# http://graphql.org/graphql-js/type
#

scalar Version

scalar Date

#
# Unix timestamp.
# http://momentjs.com/docs/#/parsing/unix-timestamp-milliseconds
#

scalar Timestamp

# TODO(burdon): Directives (for subscriptions, links, etc.)

#===================================================================================================
# Core.
# TODO(burdon): Factor out to minder-core.
# http://docs.oracle.com/javadb/10.8.3.0/ref (WHERE boolean expression)
# https://github.com/ghislainfourny/jsoniq-tutorial
# http://www.jinqjs.com/Examples
# https://jinqjs.readme.io/docs/where-filter
#===================================================================================================

# TODO(burdon): Why can't inputs be used for outputs?
# > https://github.com/graphql/graphql-js/issues/599 [me: 11/15/16]
# > https://github.com/graphql/graphql-js/issues/423 [me: 11/15/16]
# > https://github.com/apollostack/graphql-tools/issues/179

input ValueInput {
  null:       Boolean

  int:        Int
  float:      Float
  string:     String
  boolean:    Boolean

  id:         ID
  timestamp:  Timestamp

  date:       Date

  map:        [MapMutationInput]
  set:        [SetMutationInput]
  array:      [ArrayMutationInput]
  object:     [ObjectMutationInput]
}

#
# Array mutations.
# NOTE: GraphQL doesn't support maps (i.e., arbitrary keyed objects).
# Instead we declare arrays of typed objects and use Map mutations to update them.
# The underlying stored data representation can be anything (e.g., can be a JSON object), but it has to be
# queried and updated as an array.
#
# NOTE: Mutations COULD treat values as objects, but this would be wierd since they would still need
# to be queried as arrays.
#

# Multi-purpose Key x Value pair.
input KeyValue {
  key: String!
  value: ValueInput!
}

# Map (stored as array).
input MapMutationInput {
  predicate: KeyValue             # Matcher for array object value.
  value: ValueInput!
}

# Ordered set.
input SetMutationInput {
  add: Boolean                    # Default is true.
  value: ValueInput!
}

# Plain array.
input ArrayMutationInput {
  index: Int                      # Insert ordinal position (-1 to append; undefined to remove).
  value: ValueInput!              # Value to input.
}

#
# Object mutation.
# TODO(burdon): Rename FieldMutationInput
# E.g., { field: 'title', value: { string: 'Minder' } }
#

input ObjectMutationInput {
  field: String!
  value: ValueInput
}

#
# Query/Filter primitives.
#

enum Operator {
  AND,
  OR,
  NOT
}

enum Comparator {
  EQ,                       # Default
  NE,
  GT,
  GTE,
  LT,
  LTE,
  IN
}

enum Order {
  ASC,                      # Default
  DESC
}

# TODO(burdon): Should be union (boolean, comparator) but union inputs are not supported.
# union Expression = BooleanExpression | ComparatorExpression
# { op: 'OR', expr: [{ field: 'owner', ref: 'id' }, { field: 'assignee', ref: 'id' }] }

input ExpressionInput {
  op: Operator
  expr: [ExpressionInput]

  comp: Comparator          # Default: EQ
  field: String
  value: ValueInput
  ref: String
}

input OrderByInput {
  field: String
  order: Order              # Default: ASC
}

input FilterInput {

  # Data store namespace (e.g., system for User, etc.)
  namespace: String

  # TODO(burdon): Part of ID? (bucket/itemId). Or part of Global ID? Need to tell resolver where to find things.
  # TODO(burdon): ID! (User/Group ID). Should be implicit in context? And validated in frontend Auth.
  bucket: String

  # OR
  ids: [ID]
  fkeys: [String]

  # MUST
  type: String
  labels: [String]
  text: String
  expr: ExpressionInput  # Expression tree.

  # Match empty filter.
  matchAll: Boolean

  # Sort order.
  orderBy: OrderByInput

  # Group results.
  # TODO(madadam): Specify aggregation key here?
  groupBy: Boolean
}

#===================================================================================================
# Basic types.
#===================================================================================================

type Value {
  null:       Boolean

  int:        Int
  float:      Float
  string:     String
  boolean:    Boolean

  id:         ID
  timestamp:  Timestamp

  date:       Date
}

type Geo {
  lat: Float!
  lng: Float!
}

# Item sort positions.
type ListItemMeta {
  itemId: ID!                 # ID of item.
  listId: String!             # ID of list.
  order: Float!               # Order value within list.
}

type BoardColumn {
  id: ID!
  title: String!
  value: Value!
}

# Board metadata.
type Board {
  alias: String!              # Type of board.
  title: String!
  columns: [BoardColumn]
  itemMeta: [ListItemMeta]    # Map of ID x meta values (i.e., map).
}

#===================================================================================================
# Item.
# TODO(burdon): Move common fields into meta?
# http://dev.apollodata.com/tools/graphql-tools/resolvers.html#Unions-and-interfaces
# https://github.com/apollostack/graphql-server/issues/172
#===================================================================================================

interface Item {
  namespace: String           # External namespace (query provider).
  fkey: String                # Foreign key.
  bucket: ID                  # ID of User or Group (null for system item).
  type: String!
  id: ID!
  alias: String               # Short-name for URLs (unique, human-readable).
  created: Timestamp!
  modified: Timestamp!
  title: String!
  description: String
  labels: [String]
}

#===================================================================================================
# System Types.
#===================================================================================================

type User implements Item {
  namespace: String
  fkey: String
  bucket: ID
  type: String!
  id: ID!
  alias: String
  created: Timestamp!
  modified: Timestamp!
  title: String!
  description: String
  labels: [String]

  active: Boolean

  # TODO(burdon): Part of contact?
  email: String

  contact: Contact

  # TODO(burdon): Remove (only query via project links).
  tasks(filter: FilterInput): [Task]!
}

type Group implements Item {
  namespace: String
  fkey: String
  bucket: ID
  type: String!
  id: ID!
  alias: String
  created: Timestamp!
  modified: Timestamp!
  title: String!
  description: String
  labels: [String]

  whitelist: [String]
  members: [User]!

  # TODO(burdon): Shouldn't be part of Group. Instead link (since many-to-may).
  projects: [Project]!
}

#===================================================================================================
# Item Types.
#===================================================================================================

type Contact implements Item {
  namespace: String
  fkey: String
  bucket: ID
  type: String!
  id: ID!
  alias: String
  created: Timestamp!
  modified: Timestamp!
  title: String!
  description: String
  labels: [String]

  email: String
}

type Document implements Item {
  namespace: String
  fkey: String
  bucket: ID
  type: String!
  id: ID!
  alias: String
  created: Timestamp!
  modified: Timestamp!
  title: String!
  description: String
  labels: [String]

  # TODO(burdon): Move url, iconUrl, thumbnailUrl to ItemFragment
  url: String
  iconUrl: String
  thumbnailUrl: String
}

type Event implements Item {
  namespace: String
  fkey: String
  bucket: ID
  type: String!
  id: ID!
  alias: String
  created: Timestamp!
  modified: Timestamp!
  title: String!
  description: String
  labels: [String]

  location: Place
  participants: [Contact]
}

type Folder implements Item {
  namespace: String
  fkey: String
  bucket: ID
  type: String!
  id: ID!
  alias: String
  created: Timestamp!
  modified: Timestamp!
  title: String!
  description: String
  labels: [String]

  icon: String

  # JSON serialized FilterInput.
  filter: String!
}

type Place implements Item {
  namespace: String
  fkey: String
  bucket: ID
  type: String!
  id: ID!
  alias: String
  created: Timestamp!
  modified: Timestamp!
  title: String!
  description: String
  labels: [String]

  geo: Geo
}

type Project implements Item {
  namespace: String
  fkey: String
  bucket: ID
  type: String!
  id: ID!
  alias: String
  created: Timestamp!
  modified: Timestamp!
  title: String!
  description: String
  labels: [String]

  group: Group!

  # TODO(burdon): Directives for links.
  tasks: [Task]!

  # TODO(burdon): Map type (array of typed values).
  boards: [Board]

  # Sub-items.
  # TODO(madadam): Rename -> items.
  # TODO(burdon): Reimplement using SearchResult.
  refs: [Item]
}

type Task implements Item {
  namespace: String
  fkey: String
  bucket: ID
  type: String!
  id: ID!
  alias: String
  created: Timestamp!
  modified: Timestamp!
  title: String!
  description: String
  labels: [String]

  # TODO(burdon): Implement via links?
  project: Project

  # Sub-tasks.
  # TODO(burdon): Resolver should flatten the query to return the hierarchical set?
  tasks: [Task]!

  status: Int!

  # TODO(burdon): Promote to shared meta data for all items (rename "creator"? enforce on write).
  # TODO(burdon): Set automatically by mutator.
  owner: User!

  assignee: User
}

#===================================================================================================
# Root Viewer for authenticated User.
#===================================================================================================

# TODO(burdon): Combine into Viewer registration (replace /client/register)? Or top-level register query.
# TODO(burdon): Use consistently (client/background/connection manager) + Redux state/context.
type Registration {

  userId: String!

  # TODO(burdon): Multiple groups?
  groupId: String!

  clientId: String!
}

type Client {

  id: String!
}

type Viewer {

  # Authenticated user.
  user: User!

  # TODO(burdon): Multiple groups?
  group: Group!

  # Folders.
  folders: [Folder]!
}

#===================================================================================================
# Queries.
# NOTE: Must only have Input types (since regular types might be recursive and therefore not serializable).
# https://github.com/graphql/graphql-js/issues/312
#===================================================================================================

type RootQuery {

  # Current user.
  viewer: Viewer!

  # Get specific.
  item(itemId: ID!): Item!

  # Query.
  items(filter: FilterInput, offset: Int, count: Int): [Item]!

  # Search.
  # TODO(burdon): Document why different from items.
  search(filter: FilterInput, offset: Int, count: Int): [Item]!
}

#===================================================================================================
# Mutations.
#===================================================================================================

type RootMutation {

  # Generic mutation.
  updateItem(itemId: ID!, mutations: [ObjectMutationInput]!): Item!
}

#===================================================================================================
# Schema.
#===================================================================================================

schema {

  query: RootQuery

  mutation: RootMutation
}
