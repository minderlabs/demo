#
# Copyright 2016 Minder Labs.
#

#
# http://graphql.org/learn/schema
# https://facebook.github.io/graphql
#

#
# Custom scalars.
# http://graphql.org/learn/schema/#scalar-types
# http://dev.apollodata.com/tools/graphql-tools/scalars.html
# http://dev.apollodata.com/tools/graphql-tools/resolvers.html
# https://github.com/mugli/learning-graphql/blob/master/7.%20Deep%20Dive%20into%20GraphQL%20Type%20System.md
# http://graphql.org/graphql-js/type
#

scalar Timestamp
scalar Version

scalar Date

# TODO(burdon): Directives.

#
# Input types.
#

input ValueInput {
  int:      Int
  float:    Float
  string:   String
  boolean:  Boolean

  id:       ID
  date:     Date

  array:    ArrayMutationInput
  object:   ObjectMutationInput
}

#
# Array mutation.
#

input ArrayMutationInput {
  index: Int
  value: ValueInput!
}

#
# Object mutation.
# E.g., { field: 'title', value: { string: 'Minder' } }
# TODO(burdon): More compact would be { title: { string: 'Minder' }}
#

input ObjectMutationInput {
  field: String!
  value: ValueInput
}

#
# Query/Filter primitives.
#

# TODO(burdon): Why can't inputs be used for outputs?
#   https://github.com/graphql/graphql-js/issues/599
#   https://github.com/graphql/graphql-js/issues/423
#   https://github.com/apollostack/graphql-tools/issues/179

# TODO(burdon): Predicate operator.
# TODO(burdon): Build AST for query syntax? Boolean logic.
# TODO(burdon): Generalize other filter fields to predicates (except type).

input PredicateInput {
  field: String!
  value: ValueInput
  ref: String
}

input FilterInput {
  # OR
  ids: [ID]

  # MUST
  type: String
  bucket: String
  labels: [String]
  text: String

  predicate: PredicateInput
}

#
# Output types
#

type Value {
  int:      Int
  float:    Float
  string:   String
  boolean:  Boolean

  id:       ID
  date:     Date
}

type Predicate {
  field: String!
  value: Value
  ref: String
}

type Filter {
  strict: Boolean
  type: String
  bucket: String
  labels: [String]
  text: String
  predicate: Predicate
}

#
# Misc types.
#

type Geo {
  lat: Float!
  lng: Float!
}

#
# Root node.
#

type Viewer {
  id: ID!
  user: User!
}

#
# Item.
# http://dev.apollodata.com/tools/graphql-tools/resolvers.html#Unions-and-interfaces
# https://github.com/apollostack/graphql-server/issues/172
#

interface Item {
  id: ID!
  type: String!
  alias: String           # User short-name for links.
  title: String!
  labels: [String]
}

#
# Item Types:
#

type User implements Item {
  id: ID!
  type: String!
  alias: String
  title: String!
  labels: [String]

  contact: Contact
  tasks(filter: FilterInput): [Task]!
}

type Group implements Item {
  id: ID!
  type: String!
  alias: String
  title: String!
  labels: [String]

  members: [User]!
}

type Folder implements Item {
  id: ID!
  type: String!
  alias: String
  title: String!
  labels: [String]

  filter: Filter
}

type Contact implements Item {
  id: ID!
  type: String!
  alias: String
  title: String!
  labels: [String]

  email: String!
}

type Task implements Item {
  id: ID!
  type: String!
  alias: String
  title: String!
  labels: [String]
  bucket: String

  owner: User
  assignee: User
}

type Event implements Item {
  id: ID!
  type: String!
  alias: String
  title: String!
  labels: [String]

  location: Place
  participants: [Contact]
}

type Place implements Item {
  id: ID!
  type: String!
  alias: String
  title: String!
  labels: [String]

  geo: Geo
}

#
# Queries.
# NOTE: Must only have Input types (since regular types might be recursive and therefore not serializable).
# https://github.com/graphql/graphql-js/issues/312
#

type RootQuery {
  viewer: Viewer!
  folders: [Folder]!
  item(itemId: ID!): Item!
  items(filter: FilterInput, offset: Int, count: Int): [Item]!
}

#
# Mutations.
#

type RootMutation {
  updateItem(itemId: ID!, mutations: [ObjectMutationInput]!): Item!
}

#
# Schema.
#

schema {
  query: RootQuery
  mutation: RootMutation
}
