#
# Copyright 2016 Minder Labs.
#

#
# http://graphql.org/learn/schema
# https://facebook.github.io/graphql
#

#
# Custom scalars.
# http://graphql.org/learn/schema/#scalar-types
# http://dev.apollodata.com/tools/graphql-tools/scalars.html
# http://dev.apollodata.com/tools/graphql-tools/resolvers.html
# https://github.com/mugli/learning-graphql/blob/master/7.%20Deep%20Dive%20into%20GraphQL%20Type%20System.md
# http://graphql.org/graphql-js/type
#

scalar Version

scalar Date

#
# Unix timestamp.
# http://momentjs.com/docs/#/parsing/unix-timestamp-milliseconds
#

scalar Timestamp

# TODO(burdon): Directives.

#
# Input types.
#

# TODO(burdon): Why can't inputs be used for outputs?
# > https://github.com/graphql/graphql-js/issues/599 [me: 11/15/16]
# > https://github.com/graphql/graphql-js/issues/423 [me: 11/15/16]
# > https://github.com/apollostack/graphql-tools/issues/179

# TODO(burdon): Predicate operator.
# TODO(burdon): Build AST for query syntax? Boolean logic.
# TODO(burdon): Generalize other filter fields to predicates (except type).

# http://docs.oracle.com/javadb/10.8.3.0/ref (WHERE boolean expression)
# https://github.com/ghislainfourny/jsoniq-tutorial
# http://www.jinqjs.com/Examples
# https://jinqjs.readme.io/docs/where-filter

# TODO(burdon): Serialize for stored queries (rather than duplicate types).

input ValueInput {
  null:     Boolean

  int:      Int
  float:    Float
  string:   String
  boolean:  Boolean

  id:       ID
  date:     Date

  array:    ArrayMutationInput
  object:   ObjectMutationInput
}

#
# Array mutation.
#

input ArrayMutationInput {
  index: Int
  value: ValueInput!
}

#
# Object mutation.
# E.g., { field: 'title', value: { string: 'Minder' } }
#

input ObjectMutationInput {
  field: String!
  value: ValueInput
}

#
# Query/Filter primitives.
#

enum Operator {
  AND,
  OR,
  NOT
}

enum Comparator {
  EQ,                       # Default
  GT,
  LT,
  IN
}

enum Order {
  ASC,                      # Default
  DESC
}

# TODO(burdon): Should be union (boolean, comparator) but union inputs are not supported.
# union Expression = BooleanExpression | ComparatorExpression
# { op: 'OR', expr: [{ field: 'owner', ref: 'id' }, { field: 'assignee', ref: 'id' }] }

input ExpressionInput {
  op: Operator
  expr: [ExpressionInput]

  comp: Comparator          # Default: EQ
  field: String
  value: ValueInput
  ref: String
}

input OrderByInput {
  field: String
  order: Order              # Default: ASC
}

input FilterInput {

  # OR
  ids: [ID]

  # MUST
  type: String
  bucket: String
  labels: [String]
  text: String

  # Expression tree.
  expr: ExpressionInput

  # Sort order.
  orderBy: OrderByInput

  # Match empty filter.
  matchAll: Boolean
}

#
# Basic types.
#

type Geo {
  lat: Float!
  lng: Float!
}

#
# Root node.
#

type Viewer {
  id: ID!
  user: User!
}

#
# Item.
# http://dev.apollodata.com/tools/graphql-tools/resolvers.html#Unions-and-interfaces
# https://github.com/apollostack/graphql-server/issues/172
#

interface Item {
  id: ID!
  type: String!
  alias: String             # Short-name for URLs (unique, human-readable).
  created: Timestamp!
  modified: Timestamp!
  title: String!
  labels: [String]
}

#
# Item Types:
#

type User implements Item {
  id: ID!
  type: String!
  alias: String
  created: Timestamp!
  modified: Timestamp!
  title: String!
  labels: [String]

  email: String

  contact: Contact

  # TODO(burdon): Generalize to items. Move to item?
  tasks(filter: FilterInput): [Task]!
}

type Group implements Item {
  id: ID!
  type: String!
  alias: String
  created: Timestamp!
  modified: Timestamp!
  title: String!
  labels: [String]

  members: [User]!
  projects: [Project]!
}

type Folder implements Item {
  id: ID!
  type: String!
  alias: String
  created: Timestamp!
  modified: Timestamp!
  title: String!
  labels: [String]

  # JSON serialized FilterInput.
  filter: String!
}

type Contact implements Item {
  id: ID!
  type: String!
  alias: String
  created: Timestamp!
  modified: Timestamp!
  title: String!
  labels: [String]

  email: String!
}

type Project implements Item {
  id: ID!
  type: String!
  alias: String
  created: Timestamp!
  modified: Timestamp!
  title: String!
  labels: [String]

  team: Group!

  # TODO(burdon): Implement via links?
  tasks: [Task]!
}

type Task implements Item {
  id: ID!
  type: String!
  alias: String
  created: Timestamp!
  modified: Timestamp!
  title: String!
  labels: [String]

  # TODO(burdon): Promote to shared meta data for all items. Should be ID of User/Group.
  bucket: String

  # TODO(burdon): Implement via links?
  project: Project

  # TODO(burdon): Promote to shared meta data for all items.
  owner: User
  assignee: User
}

type Event implements Item {
  id: ID!
  type: String!
  alias: String
  created: Timestamp!
  modified: Timestamp!
  title: String!
  labels: [String]

  location: Place
  participants: [Contact]
}

type Place implements Item {
  id: ID!
  type: String!
  alias: String
  created: Timestamp!
  modified: Timestamp!
  title: String!
  labels: [String]

  geo: Geo
}

#
# Queries.
# NOTE: Must only have Input types (since regular types might be recursive and therefore not serializable).
# https://github.com/graphql/graphql-js/issues/312
#

type RootQuery {

  # Current user.
  viewer: Viewer!

  # Folders for current user.
  folders: [Folder]!

  # Get specific.
  item(itemId: ID!): Item!

  # Search.
  items(filter: FilterInput, offset: Int, count: Int): [Item]!
}

#
# Mutations.
#

type RootMutation {
  updateItem(itemId: ID!, mutations: [ObjectMutationInput]!): Item!
}

#
# Schema.
#

schema {
  query: RootQuery
  mutation: RootMutation
}
